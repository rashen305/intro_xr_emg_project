#!/usr/bin/env python3
"""
Real-time EMG Data Visualizer
Reads from CSV file generated by C++ collector and displays live graphs
Run this alongside the C++ collector for better visualization
"""

import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.animation as animation
from collections import deque
import numpy as np
import time
import os

# Colors for each channel
channel_colors = ['#1f77b4', '#ff7f0e', '#2ca02c', '#d62728', 
                  '#9467bd', '#8c564b', '#e377c2', '#7f7f7f']

class EMGVisualizer:
    def __init__(self, csv_filename, window_size=600, downsample_factor=1):
        self.csv_filename = csv_filename
        self.window_size = window_size  # Keep last 600 samples (3 seconds at 200Hz)
        self.downsample_factor = downsample_factor  # Plot every Nth point for smoother rendering
        
        # Initialize data buffers for 8 channels
        self.channel_data = [deque(maxlen=window_size) for _ in range(8)]
        self.timestamps = deque(maxlen=window_size)
        self.last_row = 0
        self.sample_count = 0
        self.frame_count = 0
        
        # Set up matplotlib figure and axes
        self.fig, self.ax = plt.subplots(figsize=(12, 8))
        self.ax.set_xlabel('Time (ms)', fontsize=10)
        self.ax.set_ylabel('EMG Value', fontsize=10)
        self.ax.set_ylim(-100, 100)
        self.ax.grid(True, alpha=0.3)
        self.ax.axhline(y=0, color='black', linestyle='-', linewidth=0.5)
        
        # Create lines for each channel
        self.lines = []
        for channel in range(8):
            line, = self.ax.plot([], [], color=channel_colors[channel], 
                               label=f'Channel {channel}', linewidth=1.5)
            self.lines.append(line)
        
        # Add legend
        self.ax.legend(loc='upper right', ncol=2, fontsize=9)
        
        plt.tight_layout()
    
    def update_data(self):
        """Read new data from CSV file"""
        if not os.path.exists(self.csv_filename):
            return
        
        try:
            # Read only new rows
            df = pd.read_csv(self.csv_filename, skiprows=range(1, self.last_row + 1))
            
            if len(df) == 0:
                return
            
            # Update last row counter
            self.last_row += len(df)
            
            # Add new data to buffers
            for _, row in df.iterrows():
                # Convert timestamp to milliseconds
                timestamp_ms = row['timestamp'] * 1000
                self.timestamps.append(timestamp_ms)
                
                # Add data for each channel
                for channel in range(8):
                    self.channel_data[channel].append(row[f'emg{channel+1}'])
                
                self.sample_count += 1
        
        except Exception as e:
            print(f"Error reading CSV: {e}")
    
    def animate(self, frame):
        """Animation function called by FuncAnimation"""
        self.update_data()
        self.frame_count += 1
        
        if len(self.timestamps) == 0:
            return self.lines
        
        # Convert timestamps to numpy array
        time_array = np.array(self.timestamps)
        
        # Apply downsampling for smoother rendering at high sample rates
        if self.downsample_factor > 1 and len(time_array) > self.downsample_factor:
            # Take every Nth sample
            indices = np.arange(0, len(time_array), self.downsample_factor)
            time_array_display = time_array[indices]
        else:
            time_array_display = time_array
        
        # Update each channel line
        for channel in range(8):
            if len(self.channel_data[channel]) > 0:
                channel_values = np.array(self.channel_data[channel])
                
                # Apply same downsampling to channel data
                if self.downsample_factor > 1 and len(channel_values) > self.downsample_factor:
                    channel_values_display = channel_values[indices]
                else:
                    channel_values_display = channel_values
                
                self.lines[channel].set_data(time_array_display, channel_values_display)
        
        # Scrolling window - show last 3 seconds (3000ms)
        if len(time_array) > 0:
            current_time = time_array[-1]
            window_duration = 3000  # 3 seconds in milliseconds
            self.ax.set_xlim(max(0, current_time - window_duration), current_time + 200)
        
        # Update title with sample count (update less frequently to reduce overhead)
        if self.frame_count % 10 == 0:  # Update title every 10 frames
            self.ax.set_title(f'EMG Data - 8 Channels (Samples: {self.sample_count})', fontsize=12)
        
        return self.lines
    
    def run(self):
        """Start the animation"""
        ani = animation.FuncAnimation(
            self.fig, 
            self.animate, 
            interval=150,  # Update every 150ms for smoother rendering
            blit=False,
            cache_frame_data=False
        )
        
        try:
            plt.show()
        except KeyboardInterrupt:
            print("\n\nInterrupted by user. Stopping...")
        finally:
            print(f"\nVisualization stopped. Total samples displayed: {self.sample_count}")

if __name__ == "__main__":
    import sys
    
    # Default downsample factor - adjust based on your sampling rate
    # For 200Hz: use 1 (no downsampling)
    # For 1000Hz: use 2-3
    # For 2000Hz+: use 4-5
    downsample = 1
    
    if len(sys.argv) > 1:
        csv_file = sys.argv[1]
        # Optional: specify downsample factor as second argument
        if len(sys.argv) > 2:
            downsample = int(sys.argv[2])
    else:
        # Find the most recent EMG CSV file
        import glob
        csv_files = glob.glob("emg_data_*.csv")
        if csv_files:
            csv_file = max(csv_files, key=os.path.getctime)
            print(f"Using most recent file: {csv_file}")
        else:
            print("No CSV file specified and no emg_data_*.csv files found.")
            print("Usage: python3 emg_visualizer.py <csv_filename> [downsample_factor]")
            print("  downsample_factor: 1=no downsampling, 2+=smoother at high sample rates")
            sys.exit(1)
    
    print(f"CSV file: {csv_file}")
    if downsample > 1:
        print(f"Downsample factor: {downsample} (plotting every {downsample} sample(s))")
    print("Close the plot window or press Ctrl+C to stop visualization...")
    print("=" * 60)
    
    visualizer = EMGVisualizer(csv_file, downsample_factor=downsample)
    visualizer.run()